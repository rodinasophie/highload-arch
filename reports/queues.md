# Очереди и отложенное выполнение  
Данная домашняя работа была направлена на изучение возможностей Websocket и возможностей технологии RabbitMQ. В рамках данной работы был реализован websocket-сервер для отправки новых постов пользователям напрямую от сервера, а также реализована очередь сообщений на базе RabbitMQ для оповещения друзей пользователя о новом посте пользователя.

## Детали реализации
В рамках реализации была изменена логика `/post/create`: теперь при добавлении пользователем поста, данный пост отправляется в `exchange` типа `topic`. На другой стороне топика находятся активные websocket-соединения и вычитыввют информацию из топика, отправляя ее в подписчикам пользователя в websocket-канал `/post/feed/posted`.
`Routing key` был выбран вида `userID.postID`, a `binding key` на стороне получателя сообщений из очереди `RabbitMQ` `userID.*`.

Были реализованы следующие функции:
1. `QueuePostCreatedMessage` - отправка поста в топик на стороне `/post/create`
2. `ReadPostCreatedMessageFromQueue` - чтение сообщений из топика на стороне `/post/feed/posted`

## Разворачивание стенда
```make docker-reset && make docker-queue && make docker-init && make docker-cache && make docker-backend && make docker-run```

```make init-system``` - инициализация базы данных

Открытие соединения по websocket идет по адресу `ws://127.0.0.1:8083/post/feed/posted`. Для websocket-соединения поддерживается `Authorization: Bearer <Token>`

Отправка нового поста поддерживается через `http://localhost:8083/post/create`

## Масштабирование RabbitMQ
В рамках данной реализации был развернут один инстанс RabbitMQ и все вновь созданные посты отправляются в единый `exchange` с именем `createdPosts`. При повышении нагрузки возможно развертывание нескольких инстансов RabbitMQ и управление соединениями через load-balancer/нативное clustering-решение для RabbitMQ.